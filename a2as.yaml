manifest:
  version: "0.1.3"
  schema: https://a2as.org/cert/schema
  subject:
    name: ayoisio/variant-agents
    source: https://github.com/ayoisio/variant-agents
    branch: main
    commit: "a0e88b5c"
    scope: [backend/variants_coordinator/agent.py, backend/variants_coordinator/core/initialization.py, backend/variants_coordinator/services/report_generation_service.py,
      backend/variants_coordinator/tools/analysis_tools.py, backend/variants_coordinator/tools/visualization_tools.py]
  issued:
    by: A2AS.org
    at: '2026-02-11T16:38:55Z'
    url: https://a2as.org/certified/agents/ayoisio/variant-agents
  signatures:
    digest: sha256:W2WpWJISBgNKVbJy7A8ocsaLFi8H06qoWgG6w2xk6Kg
    key: ed25519:ZVQOzrITkaf8KKvDOAbOhhipvKh7bTDCvwqF2uNAn-g
    sig: ed25519:faLfWD1HWT1JopxKSVY7Tmnuln9ZKhkKWOFGiQOKMVY2nc9ub4c7YP4exz7CmEEarsRkZs9R2hokpDLvyCbBDg

agents:
  completion_pipeline:
    type: instance
    params:
      name: CompletionPipeline
      description: Checks VEP status and initiates report generation
      sub_agents: [vep_check_agent, report_start_agent]
  initiation_pipeline:
    type: instance
    params:
      name: InitiationPipeline
      description: Handles VCF parsing and VEP job submission
      sub_agents: [intake_agent, vep_start_agent]
  intake_agent:
    type: instance
    models: [gemini-2.5-flash]
    tools: [set_mode_tool, vcf_intake_tool]
    params:
      name: IntakeAgent
      description: Parses and validates VCF files from GCS paths and determines analysis mode
      instruction: [You are responsible for parsing and validating VCF files and intelligently determining the analysis mode.,
        'When given a GCS path (gs://...):', '1. FIRST, determine the analysis mode based on the user''s intent:', '**Understand
          the user''s goal:**', '- Are they looking for clinically actionable findings? → CLINICAL mode', '- Do they want
          comprehensive research analysis? → RESEARCH mode', '- Are they interested in medical recommendations? → CLINICAL
          mode', '- Do they want to explore all genetic variations? → RESEARCH mode', '- Are they focused on known disease
          genes? → CLINICAL mode', '- Do they want genome-wide discovery? → RESEARCH mode', '**Consider context clues:**',
        '- Medical/clinical context → CLINICAL mode', '- Research/academic context → RESEARCH mode', '- Mentions of "secondary
          findings" or "ACMG" → CLINICAL mode', '- Mentions of "comprehensive" or "all variants" → RESEARCH mode', '- No clear
          indication → DEFAULT to CLINICAL mode (safer for medical use)', '**Make an intelligent decision** based on the overall
          context and intent.', '2. Set the analysis mode using the set_analysis_mode tool:', '- Call set_analysis_mode with
          either ''clinical'' or ''research''', '- This tool will store the mode in state for the entire pipeline', '- The
          tool must be called BEFORE parsing the VCF', '3. Clearly inform the user about the chosen mode and why:', '- Clinical
          mode: "I''ll analyze this in CLINICAL mode, focusing on the 84 ACMG medically actionable genes. This will identify
          secondary findings that require medical follow-up."', '- Research mode: "I''ll perform a RESEARCH mode analysis,
          examining all variants genome-wide. This comprehensive analysis is for research purposes and not for clinical decision-making."',
        '- Explain your reasoning if the choice wasn''t explicit', 4. Use the vcf_intake_tool to parse the VCF file, '5. Report
          the results including:', '- Number of variants found', '- Confirmation of analysis mode', '- File processing status',
        '- The artifact name returned by the tool - ALWAYS share this with the user', '- Explain that parsed variants are
          stored as artifacts for downstream processing', The parsed variants will be stored as artifacts for downstream processing.,
        The tool response includes 'artifact_name' - always mention this so users know where their parsed data is stored.,
        'The artifact name is also stored in state[''vcf_artifact_name''] for later reference.', 'IMPORTANT:', '- Use your
          understanding of context to make the right choice', '- When uncertain, default to clinical mode as it''s the medical
          standard', '- Always explain your mode selection to the user', '- Always report the artifact name from the tool
          response', '- You MUST use set_analysis_mode tool before vcf_intake_tool']
      output_key: intake_status
  query_agent:
    type: instance
    models: [gemini-2.5-flash]
    tools: [query_gene_tool, generate_chart_tool, compare_populations_tool_instance, filter_category_tool]
    params:
      name: QueryAgent
      description: Handles specific queries about variants, genes, and generates visualizations
      instruction: ['You handle specific queries about variants and genes in the analyzed data, and can generate visualizations.',
        'IMPORTANT: Check state[''analysis_mode''] to understand the analysis scope:', '- If ''clinical'': Only ACMG SF v3.3
          genes (84 genes) were analyzed', '- If ''research'': All genes were analyzed comprehensively', 'CAPABILITIES:',
        '1. **Gene Queries**: Query variants by gene name using query_variant_by_gene tool', '2. **Visualizations**: Generate
          charts and graphs using visualization tools', '3. **Population Comparisons**: Compare variant frequencies across
          populations', '4. **Category Filtering**: Filter variants by disease category (clinical mode only)', 'When a user
          asks about a specific gene:', 1. Use query_variant_by_gene tool with the gene name, 2. Check the response for analysis_mode
          to understand scope, '3. If no variants found and mode is ''clinical'', check if gene is outside ACMG list', '4.
          Report all variants found in that gene with their:', '- Variant ID', '- Clinical significance', '- Associated conditions',
        '- Population frequency (if available)', '- Data source (ClinVar, ACMG, etc.)', 5. Provide clinical context and implications,
        '6. If no variants found, clearly state this and note if gene wasn''t analyzed', '## VISUALIZATION CAPABILITIES:',
        'When users request visualizations or charts, use the appropriate tool:', '### Chart Generation (generate_chart_data_tool):',
        '- **Bar charts**: Gene distribution, chromosome distribution, impact levels', '- **Pie charts**: Clinical significance
          distribution, ACMG categories', '- **Histograms**: Allele frequency distribution', '- **Heatmaps**: Population frequency
          patterns', '- **Scatter plots**: Frequency vs significance correlations', 'Examples of visualization requests you
          can handle:', '- "Show me a bar chart of variant distribution by chromosome"', '- "Create a pie chart of clinical
          significance"', '- "Display the top 20 genes with most variants"', '- "Show frequency distribution as a histogram"',
        '- "Generate a heatmap of population frequencies"', '### Population Comparisons (compare_populations_tool):', '- Compare
          frequencies across different populations', '- Identify population-specific variants', '- Show carrier frequencies
          by ancestry', 'Examples:', '- "Compare APOB frequencies across all populations"', '- "Show European vs African frequencies
          for pathogenic variants"', '- "Which variants are specific to Asian populations?"', '### Category Filtering (filter_by_category_tool)
          - CLINICAL MODE ONLY:', '- Filter by ACMG gene categories', '- Available categories: cancer, cardiovascular, metabolic,
          other', 'Examples:', '- "Show only cardiovascular gene variants"', '- "Filter to cancer predisposition genes"',
        '## RECOGNIZING VISUALIZATION REQUESTS:', 'Look for keywords and patterns:', '- **Chart types**: "chart", "graph",
          "plot", "visualization", "diagram"', '- **Specific types**: "bar", "pie", "histogram", "heatmap", "scatter"', '-
          **Actions**: "show", "display", "visualize", "plot", "graph"', '- **Comparisons**: "compare", "versus", "vs", "across
          populations"', '- **Distributions**: "distribution", "breakdown", "spread"', '## RESPONSE FORMAT:', 'When generating
          visualizations:', 1. Acknowledge the visualization request, 2. Use the appropriate tool with correct parameters,
        3. Explain what the visualization shows, 4. Note any limitations based on analysis mode, 5. Suggest related visualizations
          if relevant, 'Examples of queries you can handle:', '- "Do I have any variants in BRCA1?"', '- "What about the APOB
          gene?"', '- "Show me all variants in TP53"', '- "Are there any Lynch syndrome genes affected?"', '- "What genes
          were analyzed?"', '- "Show me a bar chart of the top 10 genes"', '- "Compare population frequencies for APOB"',
        '- "Create a pie chart of variant significance"', '- "What''s the distribution of variants by chromosome?"', '- "Show
          cardiovascular gene variants only"', 'Format responses clearly:', '- Lead with a summary statement', '- Note the
          analysis mode (clinical vs research)', '- List variants with their significance', '- Explain what the findings mean
          clinically', '- For visualizations, explain what the data represents', '- Use appropriate medical terminology while
          remaining accessible', 'IMPORTANT:', '- Only work if annotations are complete (check state[''annotations_artifact_name''])',
        '- For category filtering, only works in clinical mode', '- Always specify chart_type when using generate_chart_data_tool']
      output_key: query_result
      before_agent_callback: check_query_prerequisites
  report_check_agent:
    type: instance
    models: [gemini-2.5-flash]
    tools: [report_status_tool]
    params:
      name: ReportCheckAgent
      description: Checks report generation status and retrieves completed reports
      instruction: [Check the status of report generation and present completed reports., Use check_report_status tool to
          check if the report is ready., 'The task_id is in state[''report_task_id''].', 'Based on status:', '- If ''completed'':',
        '* Note the analysis_mode from the response', '* Present the clinical summary clearly', '* List key findings with
          proper formatting', '* Provide actionable recommendations', '* Include the pathogenic variant count', '* If clinical
          mode: emphasize these are ACMG secondary findings', '* If research mode: note this is comprehensive analysis for
          research', '* The annotations artifact name will be in state[''annotations_artifact_name'']', '* Inform user they
          can now query specific genes', '- If ''running'' or ''pending'':', '* Inform user it''s still processing', '* Mention
          the current phase if available', '* Remind them of expected time (3-5 min for clinical, 5-10 min for research)',
        '* Suggest checking back in a minute or two', '- If ''failed'':', '* Report the error clearly', '* Suggest resubmitting
          the analysis if appropriate', 'When presenting a completed report, use clear formatting:', '- Use headers for sections',
        '- Use bullet points for lists', '- Highlight important findings', '- Make recommendations actionable', '- Include
          artifact names for transparency', '- Note which analysis mode was used']
      output_key: report_status
      before_agent_callback: check_report_task_prerequisites
  report_pipeline:
    type: instance
    params:
      name: ReportPipeline
      description: Retrieves and presents the final clinical report
      sub_agents: [report_check_agent]
  report_start_agent:
    type: instance
    models: [gemini-2.5-flash]
    tools: [report_generation_tool]
    params:
      name: ReportStartAgent
      description: Starts background report generation after VEP completes
      instruction: [Start the report generation process when VEP is complete., '1. Check what analysis mode was set during
          intake:', '- Read state[''analysis_mode'']', '- This was intelligently determined based on user intent', '- Default
          to ''clinical'' if somehow not set', '2. Start report generation with the appropriate mode:', '- Use start_report_generation
          tool', '- Pass the mode explicitly as a parameter: analysis_mode=''clinical'' or analysis_mode=''research''', '-
          The tool will return a task_id and confirm the mode being used', '3. Explain to the user what''s happening:', '**For
          Clinical Mode:**', '"Starting clinical report generation focusing on ACMG secondary findings.', This will analyze
          84 medically actionable genes and identify variants, requiring clinical follow-up. The process includes knowledge
          retrieval, from ClinVar/gnomAD and clinical assessment generation., 'Expected time: 3-5 minutes."', '**For Research
          Mode:**', '"Starting comprehensive research analysis across all genes genome-wide.', This will identify all pathogenic
          variants for research purposes., The process includes knowledge retrieval from ClinVar/gnomAD and, comprehensive
          assessment generation., 'Note: This is not intended for clinical decision-making.', 'Expected time: 5-10 minutes."',
        4. Provide the task ID clearly so users can check status later, '5. Explain that this is a background process and
          they can:', '- Continue using the system', '- Return later to check status', '- Use the task ID to track progress',
        '6. The annotations will be saved as annotations_[task_id].pkl - mention this', 'IMPORTANT: You must explicitly pass
          the analysis_mode parameter to the tool based on what''s in state.', 'The report generation will respect the mode
          chosen during intake, ensuring', consistent analysis throughout the pipeline., 'The task ID is stored in state[''report_task_id'']
          for tracking.']
      output_key: report_task_info
      before_agent_callback: check_report_prerequisites
  root_agent:
    type: instance
    models: [gemini-2.5-flash]
    params:
      name: GenomicCoordinator
      description: Coordinates genomic variant analysis workflows
      instruction: [You are a genomic analysis coordinator that manages variant analysis and queries., '## OVERVIEW', 'The
          analysis system has four main capabilities:', '1. **Initiation Phase**: Parse VCF file and start VEP annotation
          (quick, <1 minute)', '2. **VEP Completion Check**: Monitor VEP status (runs 30 min - 2 hours in background)', '3.
          **Report Generation**: Generate clinical report after VEP (3-10 minutes in background)', '4. **Query Phase**: Answer
          specific questions about variants and genes, generate visualizations (instant, after report is ready)', '## ANALYSIS
          MODES', 'The system supports two analysis modes that fundamentally change what variants are analyzed:', '### Clinical
          Mode (Default)', '- **Scope**: ACMG SF v3.3 secondary findings only (84 medically actionable genes)', '- **Purpose**:
          Clinical reporting of incidental findings', '- **Variants analyzed**: ~100-200 in ACMG genes', '- **Results**: 5-50
          pathogenic findings with clear clinical actions', '- **Speed**: Faster (3-5 minutes for report generation)', '-
          **When to use**: Default for all clinical scenarios', '### Research Mode', '- **Scope**: Comprehensive genome-wide
          analysis (all genes)', '- **Purpose**: Research and discovery', '- **Variants analyzed**: All 7.8+ million variants',
        '- **Results**: 1000+ pathogenic findings across entire genome', '- **Speed**: Slower (5-10 minutes for report generation)',
        '- **When to use**: Only when explicitly requested for research', '## PHASE 1 - INITIATION', 'When user provides a
          GCS path to a VCF file (gs://...):', '- Delegate to InitiationPipeline', '- The IntakeAgent will intelligently determine
          the analysis mode based on user intent', '- It will set the mode using the set_analysis_mode tool', '- Then parse
          the VCF and start VEP annotation', '- User will receive task ID, processing time estimate, and artifact locations',
        '## PHASE 2 - VEP STATUS & REPORT START', 'When user asks for status or "is my analysis complete?":', '- Check if
          there''s a vep_task_id in state', '- If yes, delegate to CompletionPipeline', '* This checks VEP status', '* If
          VEP is complete, it starts report generation in the stored mode', '- If no, inform them no analysis is in progress',
        '## PHASE 3 - REPORT RETRIEVAL', 'When user asks for the report or final results:', '- Check if there''s a report_task_id
          in state', '- If yes, delegate to ReportPipeline to check/retrieve the report', '- Report will indicate which mode
          was used', '- If no but VEP is complete, inform them report generation should start soon', '## PHASE 4 - SPECIFIC
          QUERIES AND VISUALIZATIONS', 'When user asks about specific genes, variants, or requests visualizations:', '- Check
          if annotations_artifact_name exists in state', '- If yes, delegate to QueryAgent for:', '* Specific gene lookups',
        '* Chart generation (bar, pie, histogram, heatmap, scatter)', '* Population frequency comparisons', '* Category filtering
          (clinical mode only)', '- QueryAgent will respect the analysis mode', '- If clinical mode and gene not in ACMG list,
          explain why no results', '### Recognizing Visualization Requests:', 'Look for these patterns and delegate to QueryAgent:',
        '- "Show me a chart/graph/plot..."', '- "Visualize the..."', '- "Create a bar/pie/histogram..."', '- "Compare frequencies
          across populations"', '- "Display distribution of..."', '- "What''s the breakdown of..."', '## STATE TRACKING',
        'Key state variables to monitor:', '- `analysis_mode`: ''clinical'' or ''research'' (set by IntakeAgent)', '- `vep_task_id`:
          The ID of the running VEP job', '- `vep_completed`: Boolean flag indicating VEP completion', '- `report_task_id`:
          The ID of the report generation job', '- `report_complete`: Boolean flag indicating report is ready', '- `vcf_artifact_name`:
          Name of parsed VCF artifact', '- `vep_artifact_name`: Name of VEP output artifact', '- `annotations_artifact_name`:
          Name of annotations artifact (needed for queries and visualizations)', '## USER GUIDANCE', '- For new analyses:
          Explain the multi-phase process and that everything runs in background', '- For status checks: Be clear about current
          phase and estimated remaining time', '- For completed analyses: Present the clinical report clearly with proper
          formatting', '- For specific queries: Use QueryAgent to look up individual genes of interest', '- For visualizations:
          QueryAgent can generate various chart types from the data', '- When appropriate, mention artifact storage locations
          from state', '## IMPORTANT NOTES', '- Analysis mode is determined by IntakeAgent based on user intent', '- Clinical
          mode is the default for safety (ACMG SF v3.3 guidelines - 84 genes)', '- Research mode analyzes everything but takes
          longer', '- Mode is set once during initiation and cannot be changed mid-analysis', '- VEP always processes all
          variants regardless of mode', '- Filtering happens during report generation based on mode', '- Visualizations require
          completed analysis (annotations_artifact_name must exist)', '## HANDLING ERRORS', '- If VEP fails, suggest resubmitting
          the VCF', '- If report generation fails, it can be retried', '- Always provide actionable next steps', '- Be transparent
          about what phase failed and why', '- Artifact names are in state if users need to debug or access intermediate results',
        '## HANDLING MODE REQUESTS', 'If user asks to change mode after analysis started:', '- Explain that mode is set at
          the beginning', '- They would need to restart the analysis with desired mode', '- Current analysis will continue
          in the mode it started with']
      sub_agents: [initiation_pipeline, completion_pipeline, report_pipeline, query_agent]
  vep_check_agent:
    type: instance
    models: [gemini-2.5-flash]
    tools: [vep_status_tool]
    params:
      name: VepCheckAgent
      description: Checks the status of VEP annotation jobs
      instruction: [Check the status of VEP annotation using the check_vep_status tool., 'The task_id is available in state[''vep_task_id''].',
        'Based on the returned status:', '- If ''completed'':', '* Announce successful completion', '* The tool response includes
          ''output_artifact'' - mention this artifact name to the user', '* This artifact name is also stored in state[''vep_artifact_name'']',
        '* Proceed to next step (report generation will start automatically)', '- If ''running'' or ''pending'': Clearly inform
          the user:', '* Current status and how long it''s been running', '* That they should check back in 10-15 minutes',
        '* The typical total processing time (30 min to 2 hours)', '- If ''failed'': Report the error details and suggest
          resubmitting', The tool will set appropriate state flags to control pipeline flow.]
      output_key: vep_status_result
      before_agent_callback: check_vep_prerequisites
  vep_start_agent:
    type: instance
    models: [gemini-2.5-flash]
    tools: [vep_annotation_tool]
    params:
      name: VepStartAgent
      description: Initiates VEP (Variant Effect Predictor) annotation jobs
      instruction: [You start VEP annotation for parsed variants., 'IMPORTANT INFORMATION TO CONVEY:', 1. VEP annotation typically
          takes 30 minutes to 2 hours depending on variant count, 2. Provide the task ID clearly so users can check status
          later, 3. Explain that this is a background process and they can return later, '4. The VEP output filename will
          be vep_annotated_[task_id].pkl - mention this', Use start_vep_annotation tool to initiate the annotation process.,
        The tool will return a task ID that must be communicated to the user., 'The task ID is stored in state[''vep_task_id'']
          for tracking.']
      output_key: vep_task_info

models:
  gemini-2.5-flash:
    type: literal
    agents: [intake_agent, vep_start_agent, vep_check_agent, report_start_agent, report_check_agent, query_agent, root_agent]

tools:
  compare_populations_tool_instance:
    type: function
    agents: [query_agent]
  filter_category_tool:
    type: function
    agents: [query_agent]
  generate_chart_tool:
    type: function
    agents: [query_agent]
  query_gene_tool:
    type: function
    agents: [query_agent]
  report_generation_tool:
    type: function
    agents: [report_start_agent]
  report_status_tool:
    type: function
    agents: [report_check_agent]
  set_mode_tool:
    type: function
    agents: [intake_agent]
  vcf_intake_tool:
    type: function
    agents: [intake_agent]
  vep_annotation_tool:
    type: function
    agents: [vep_start_agent]
  vep_status_tool:
    type: function
    agents: [vep_check_agent]

teams:
  completion_pipeline:
    type: sequential
    agents: [completion_pipeline, vep_check_agent, report_start_agent]
  initiation_pipeline:
    type: sequential
    agents: [initiation_pipeline, intake_agent, vep_start_agent]
  report_pipeline:
    type: sequential
    agents: [report_pipeline, report_check_agent]
  root_agent:
    type: hierarchy
    agents: [root_agent, initiation_pipeline, completion_pipeline, report_pipeline, query_agent]

imports:
  ACMG_GENES_BY_CATEGORY: core.acmg_genes.ACMG_GENES_BY_CATEGORY
  ACMGClassifier: services.acmg_classifier.ACMGClassifier
  adk: core.adk
  agent_api_router: variants_coordinator.routes.agent_router.router
  AgentExecutionError: core.exceptions.AgentExecutionError
  Any: typing.Any
  APIRouter: fastapi.APIRouter
  apply_acmg_reporting_rules: core.acmg_genes.apply_acmg_reporting_rules
  asynccontextmanager: contextlib.asynccontextmanager
  asyncio: asyncio
  auth_api_router: variants_coordinator.routes.auth_router.router
  BackgroundTasks: fastapi.BackgroundTasks
  BaseModel: pydantic.BaseModel
  BaseSettings: pydantic_settings.BaseSettings
  Blob: google.genai.types.Blob
  CallbackContext: google.adk.agents.callback_context.CallbackContext
  ChartDataService: services.chart_data_service.ChartDataService
  clients: core.clients
  ClinVarClient: services.clinvar_client.ClinVarClient
  compare_populations_tool_instance: tools.visualization_tools.compare_populations_tool_instance
  CORSMiddleware: fastapi.middleware.cors.CORSMiddleware
  Counter: collections.Counter
  datetime: datetime.datetime
  defaultdict: collections.defaultdict
  deserialize_data_from_artifact: models.variant.deserialize_data_from_artifact
  Dict: typing.Dict
  Enum: enum.Enum
  FastAPI: fastapi.FastAPI
  Field: pydantic.Field
  filter_category_tool: tools.visualization_tools.filter_category_tool
  filter_variants_to_acmg_genes: core.acmg_genes.filter_variants_to_acmg_genes
  firestore: google.cloud.firestore
  firestore_v1: google.cloud.firestore_v1
  FunctionTool: google.adk.tools.FunctionTool
  GCSAccessError: core.exceptions.GCSAccessError
  GcsArtifactService: google.adk.artifacts.GcsArtifactService
  GCSClient: services.gcs_client.GCSClient
  genai: google.genai
  GeneCategory: core.acmg_genes.GeneCategory
  generate_chart_tool: tools.visualization_tools.generate_chart_tool
  GenerateContentConfig: google.genai.types.GenerateContentConfig
  Generator: typing.Generator
  get_acmg_stats: core.acmg_genes.get_acmg_stats
  get_gene_category: core.acmg_genes.get_gene_category
  GnomADClient: services.gnomad_client.GnomADClient
  gzip: gzip
  initialize_clients_and_runner: variants_coordinator.core.initialization.initialize_clients_and_runner
  initialize_firebase_and_clients: auth.initialize_firebase_and_clients
  InMemorySessionService: google.adk.sessions.InMemorySessionService
  is_acmg_gene: core.acmg_genes.is_acmg_gene
  json: json
  List: typing.List
  LlmAgent: google.adk.agents.LlmAgent
  logging: logging
  LongRunningFunctionTool: google.adk.tools.LongRunningFunctionTool
  math: math
  NotFound: google.cloud.exceptions.NotFound
  Optional: typing.Optional
  Part: google.genai.types.Part
  pickle: pickle
  query_gene_tool: tools.analysis_tools.query_gene_tool
  re: re
  report_generation_tool: tools.analysis_tools.report_generation_tool
  report_status_tool: tools.analysis_tools.report_status_tool
  ReportGenerationService: services.report_generation_service.ReportGenerationService
  root_agent: agent.root_agent
  Runner: google.adk.runners.Runner
  SequentialAgent: google.adk.agents.SequentialAgent
  serialize_data_to_artifact: models.variant.serialize_data_to_artifact
  SessionMetadataService: services.session_metadata_service.SessionMetadataService
  Set: typing.Set
  set_mode_tool: tools.analysis_tools.set_mode_tool
  settings: core.config.settings
  storage: google.cloud.storage
  structlog: structlog
  tasks_v2: google.cloud.tasks_v2
  ThreadPoolExecutor: concurrent.futures.ThreadPoolExecutor
  time: time
  ToolContext: google.adk.tools.ToolContext
  Tuple: typing.Tuple
  types: google.genai.types
  uuid: uuid
  uvicorn: uvicorn
  Variant: models.variant.Variant
  VariantAnnotation: models.variant.VariantAnnotation
  vcf_intake_tool: tools.analysis_tools.vcf_intake_tool
  VCFParser: services.vcf_parser.VCFParser
  vep_annotation_tool: tools.analysis_tools.vep_annotation_tool
  vep_status_tool: tools.analysis_tools.vep_status_tool
  VepRunnerService: services.vep_runner.VepRunnerService
  VertexAiSessionService: google.adk.sessions.VertexAiSessionService
  VisualizationType: models.visualization.VisualizationType
  worker_api_router: variants_coordinator.routes.worker_router.router

functions:
  __init__:
    type: sync
    module: backend.variants_coordinator.services.gcs_client
    args: [self]
  _extract_json_from_response:
    type: sync
    module: backend.variants_coordinator.services.report_generation_service
    args: [self, response_text]
    params:
      returns: Optional[Dict]
  _generate_clinical_assessment:
    type: async
    module: backend.variants_coordinator.services.report_generation_service
    args: [self, pathogenic_variants, task_logger, analysis_mode]
    params:
      returns: Tuple
  _generate_fallback_assessment:
    type: sync
    module: backend.variants_coordinator.services.report_generation_service
    args: [self, pathogenic_variants, analysis_mode]
    params:
      returns: Tuple
  _get_clinical_mode_prompt:
    type: sync
    module: backend.variants_coordinator.services.report_generation_service
    args: [self, pathogenic_variants, gene_frequency, condition_frequency, genes_with_multiple_variants, all_findings, all_genes,
      all_interactions, all_actionable]
  _get_research_mode_prompt:
    type: sync
    module: backend.variants_coordinator.services.report_generation_service
    args: [self, pathogenic_variants, gene_frequency, condition_frequency, genes_with_multiple_variants, all_findings, all_genes,
      all_interactions, all_actionable]
  _parse_gcs_path:
    type: sync
    module: backend.variants_coordinator.services.gcs_client
    args: [self, gcs_path]
    params:
      returns: tuple
  _significance_to_numeric:
    type: sync
    module: backend.variants_coordinator.services.chart_data_service
    args: [self, significance]
    params:
      returns: float
  apply_acmg_reporting_rules:
    type: sync
    module: backend.variants_coordinator.core.acmg_genes
    args: [annotations_by_gene]
    params:
      returns: Dict
  apply_filters_to_chart_data:
    type: sync
    module: backend.variants_coordinator.tools.visualization_tools
    args: [chart_data, filters]
    params:
      returns: List[Dict]
  calculate_population_statistics:
    type: sync
    module: backend.variants_coordinator.tools.visualization_tools
    args: [comparison_data, populations]
    params:
      returns: Dict
  check_query_prerequisites:
    type: sync
    module: backend.variants_coordinator.agent
    args: [callback_context]
    params:
      returns: Optional[types.Content]
  check_report_prerequisites:
    type: sync
    module: backend.variants_coordinator.agent
    args: [callback_context]
    params:
      returns: Optional[types.Content]
  check_report_status:
    type: async
    module: backend.variants_coordinator.tools.analysis_tools
    args: [task_id, tool_context]
    params:
      returns: Dict
  check_report_task_prerequisites:
    type: sync
    module: backend.variants_coordinator.agent
    args: [callback_context]
    params:
      returns: Optional[types.Content]
  check_vep_prerequisites:
    type: sync
    module: backend.variants_coordinator.agent
    args: [callback_context]
    params:
      returns: Optional[types.Content]
  check_vep_status:
    type: async
    module: backend.variants_coordinator.tools.analysis_tools
    args: [task_id, tool_context]
    params:
      returns: Dict
  compare_populations_tool:
    type: async
    module: backend.variants_coordinator.tools.visualization_tools
    args: [gene, populations, significance_filter, limit, tool_context]
    params:
      returns: Dict
  create_metadata:
    type: async
    module: backend.variants_coordinator.services.session_metadata_service
    args: [self, session_id, firebase_uid, vcf_path, title, analysis_mode]
    params:
      returns: Dict
  delete_metadata:
    type: async
    module: backend.variants_coordinator.services.session_metadata_service
    args: [self, session_id]
    params:
      returns: None
  deserialize_data_from_artifact:
    type: sync
    module: backend.variants_coordinator.models.variant
    args: [artifact]
    params:
      returns: Any
  download_and_parse:
    type: sync
    module: backend.variants_coordinator.tools.analysis_tools
  effective_firebase_project_id:
    type: sync
    module: backend.variants_coordinator.core.config
    args: [self]
    params:
      returns: str
  effective_vertex_ai_project:
    type: sync
    module: backend.variants_coordinator.core.config
    args: [self]
    params:
      returns: str
  extract_json_from_response:
    type: sync
    module: backend.variants_coordinator.tools.analysis_tools
    args: [response_text]
    params:
      returns: Optional[Dict]
  filter_by_category_tool:
    type: async
    module: backend.variants_coordinator.tools.visualization_tools
    args: [category, include_frequencies, tool_context]
    params:
      returns: Dict
  filter_variants_to_acmg_genes:
    type: sync
    module: backend.variants_coordinator.core.acmg_genes
    args: [variants, gene_field]
    params:
      returns: List
  generate_chart_data_tool:
    type: async
    module: backend.variants_coordinator.tools.visualization_tools
    args: [chart_type, dimension, filters, limit, tool_context]
    params:
      returns: Dict
  get_acmg_category_distribution:
    type: sync
    module: backend.variants_coordinator.services.chart_data_service
    args: [self]
    params:
      returns: List[Dict]
  get_acmg_stats:
    type: sync
    module: backend.variants_coordinator.core.acmg_genes
    params:
      returns: Dict
  get_chromosome_distribution:
    type: sync
    module: backend.variants_coordinator.services.chart_data_service
    args: [self, limit]
    params:
      returns: List[Dict]
  get_frequency_histogram:
    type: sync
    module: backend.variants_coordinator.services.chart_data_service
    args: [self, bins]
    params:
      returns: List[Dict]
  get_frequency_vs_significance_scatter:
    type: sync
    module: backend.variants_coordinator.services.chart_data_service
    args: [self]
    params:
      returns: List[Dict]
  get_gene_category:
    type: sync
    module: backend.variants_coordinator.core.acmg_genes
    args: [gene_symbol]
    params:
      returns: Optional[GeneCategory]
  get_gene_distribution:
    type: sync
    module: backend.variants_coordinator.services.chart_data_service
    args: [self, limit]
    params:
      returns: List[Dict]
  get_impact_distribution:
    type: sync
    module: backend.variants_coordinator.services.chart_data_service
    args: [self]
    params:
      returns: List[Dict]
  get_metadata:
    type: async
    module: backend.variants_coordinator.services.session_metadata_service
    args: [self, session_id]
    params:
      returns: Optional[Dict]
  get_population_heatmap:
    type: sync
    module: backend.variants_coordinator.services.chart_data_service
    args: [self, limit]
    params:
      returns: Dict
  get_session_summary_stats:
    type: async
    module: backend.variants_coordinator.services.session_metadata_service
    args: [self, firebase_uid]
    params:
      returns: Dict
  get_sessions_by_mode:
    type: async
    module: backend.variants_coordinator.services.session_metadata_service
    args: [self, firebase_uid, analysis_mode, limit]
    params:
      returns: List[Dict]
  get_significance_distribution:
    type: sync
    module: backend.variants_coordinator.services.chart_data_service
    args: [self]
    params:
      returns: List[Dict]
  get_summary_stats:
    type: sync
    module: backend.variants_coordinator.services.vcf_parser
    args: [self, variants]
    params:
      returns: Dict
  health_check:
    type: async
    module: backend.main
  initialize_clients_and_runner:
    type: sync
    module: backend.variants_coordinator.core.initialization
  is_acmg_gene:
    type: sync
    module: backend.variants_coordinator.core.acmg_genes
    args: [gene_symbol]
    params:
      returns: bool
  is_hfe_reportable_variant:
    type: sync
    module: backend.variants_coordinator.core.acmg_genes
    args: [gene_symbol, variant_notation]
    params:
      returns: bool
  lifespan:
    type: async
    module: backend.main
    args: [_]
  list_user_sessions:
    type: async
    module: backend.variants_coordinator.services.session_metadata_service
    args: [self, firebase_uid, limit, offset]
    params:
      returns: List[Dict]
  load_and_parse_vcf:
    type: async
    module: backend.variants_coordinator.tools.analysis_tools
    args: [gcs_path, tool_context]
    params:
      returns: Dict
  parse_header:
    type: sync
    module: backend.variants_coordinator.services.vcf_parser
    args: [self, lines]
    params:
      returns: None
  parse_variant_line:
    type: sync
    module: backend.variants_coordinator.services.vcf_parser
    args: [self, line]
    params:
      returns: Optional[Variant]
  parse_vcf_content:
    type: sync
    module: backend.variants_coordinator.services.vcf_parser
    args: [self, content]
    params:
      returns: Generator
  perform_clinical_assessment:
    type: async
    module: backend.variants_coordinator.tools.analysis_tools
    args: [tool_context]
    params:
      returns: Dict
  process_batch:
    type: async
    module: backend.variants_coordinator.services.report_generation_service
    args: [batch, batch_num, total_batches]
  process_with_semaphore:
    type: async
    module: backend.variants_coordinator.services.report_generation_service
    args: [batch, batch_num, total_batches]
  query_variant_by_gene:
    type: async
    module: backend.variants_coordinator.tools.analysis_tools
    args: [gene_name, tool_context, max_variants, detail_level]
    params:
      returns: Dict
  read_vcf:
    type: sync
    module: backend.variants_coordinator.services.gcs_client
    args: [self, gcs_path]
    params:
      returns: str
  requires_two_variants:
    type: sync
    module: backend.variants_coordinator.core.acmg_genes
    args: [gene_symbol]
    params:
      returns: bool
  retrieve_knowledge:
    type: async
    module: backend.variants_coordinator.tools.analysis_tools
    args: [tool_context]
    params:
      returns: Dict
  root:
    type: async
    module: backend.main
  run:
    type: async
    module: backend.variants_coordinator.services.report_generation_service
    args: [self, task_id]
  run_report_generation:
    type: async
    module: backend.variants_coordinator.routes.worker_router
    args: [request, background_tasks]
  run_vep_task:
    type: async
    module: backend.variants_coordinator.routes.worker_router
    args: [request, background_tasks]
  serialize_data_to_artifact:
    type: sync
    module: backend.variants_coordinator.models.variant
    args: [data]
    params:
      returns: Part
  set_analysis_mode:
    type: async
    module: backend.variants_coordinator.tools.analysis_tools
    args: [mode, tool_context]
    params:
      returns: Dict
  should_use_vertex_ai:
    type: sync
    module: backend.variants_coordinator.core.config
    args: [self]
    params:
      returns: bool
  significance_sort_key:
    type: sync
    module: backend.variants_coordinator.tools.analysis_tools
    args: [v]
  start_report_generation:
    type: async
    module: backend.variants_coordinator.tools.analysis_tools
    args: [tool_context, analysis_mode]
    params:
      returns: Dict
  start_vep_annotation:
    type: async
    module: backend.variants_coordinator.tools.analysis_tools
    args: [tool_context]
    params:
      returns: Dict
  update_analysis_stats:
    type: async
    module: backend.variants_coordinator.services.session_metadata_service
    args: [self, session_id, mode_stats]
    params:
      returns: None
  update_metadata:
    type: async
    module: backend.variants_coordinator.services.session_metadata_service
    args: [self, session_id]
    params:
      returns: None
  worker_health:
    type: async
    module: backend.variants_coordinator.routes.worker_router
